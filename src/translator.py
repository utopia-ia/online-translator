#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Translation Module
-----------------
Handles text translation functionality for the Online-Translator application.
Provides translation services using MLX models and manages translation context.

Copyright (c) 2024 Kiko Cisneros
Licensed under the MIT License (see LICENSE file for details)
"""

import time
import re
from collections import deque
from mlx_lm import load, generate
import mlx.core as mx
from . import config


class TextTranslator:
    """Handles text translation using MLX models"""
    
    def __init__(self):
        self.translation_model = None
        self.translation_tokenizer = None
        
        # Translation history for context
        self.translation_history = deque(maxlen=10)  # Keep last 10 translations for context
        
        # Timing statistics
        self.translation_times = deque(maxlen=20)  # Keep last 20 translation times
        self.model_load_times = deque(maxlen=5)   # Keep last 5 model load times
        self.total_translations = 0
        self.total_characters_translated = 0
        
        # MLX device info
        self.device = mx.default_device()
        print(f"üîß MLX Translation using device: {self.device}")
        
        self.load_translation_model()
        
    def load_translation_model(self):
        """Load MLX translation model (Qwen) with GPU optimization"""
        try:
            print(f"üîÑ Loading translation model: {config.TRANSLATION_MODEL}")
            print(f"üîß Target device: {self.device}")
            load_start_time = time.time()
            
            # Clear MLX cache before loading
            mx.clear_cache()
            
            self.translation_model, self.translation_tokenizer = load(config.TRANSLATION_MODEL)
            
            load_time = time.time() - load_start_time
            self.model_load_times.append(load_time)
            
            # Check memory usage after loading
            try:
                peak_memory = mx.get_peak_memory() / 1024 / 1024  # Convert to MB
                cache_memory = mx.metal.get_cache_memory() / 1024 / 1024 if hasattr(mx.metal, 'get_cache_memory') else 0
                print(f"‚úÖ Translation model loaded successfully in {load_time:.2f}s")
                print(f"üîß GPU Memory - Peak: {peak_memory:.1f} MB, Cache: {cache_memory:.1f} MB")
            except Exception as e:
                print(f"‚úÖ Translation model loaded successfully in {load_time:.2f}s")
                if config.ENABLE_DEBUG_LOGGING:
                    print(f"Memory info not available: {e}")
            
            if config.ENABLE_DEBUG_LOGGING:
                print(f"Model details: {config.TRANSLATION_MODEL}")
                print(f"Model device: {self.device}")
                
        except Exception as e:
            print(f"‚ùå Error loading translation model: {e}")
            print("üîÑ Falling back to simple translation...")
            
    def translate_text(self, text, target_language="es", previous_text=None):
        """Translate text using MLX model with GPU optimization and optional context"""
        if not text.strip():
            return ""
            
        try:
            if self.translation_model is None:
                print(f"‚ö†Ô∏è  Translation model not loaded, using fallback for: '{text[:30]}...'")
                return f"[{target_language.upper()}] {text}"
                
            # Start timing
            start_time = time.time()
            
            # Log translation request with context info
            context_info = f" (with context)" if previous_text else ""
            print(f"üåê Starting translation{context_info}: '{text[:50]}{'...' if len(text) > 50 else ''}' -> {target_language.upper()}")
            
            # Comprehensive language code mapping
            language_names = {
                # Major languages
                "es": "Spanish", "en": "English", "fr": "French", "de": "German", 
                "it": "Italian", "pt": "Portuguese", "ru": "Russian", "zh": "Chinese",
                "ja": "Japanese", "ko": "Korean", "ar": "Arabic", "hi": "Hindi",
                
                # European languages
                "nl": "Dutch", "sv": "Swedish", "da": "Danish", "no": "Norwegian",
                "fi": "Finnish", "pl": "Polish", "cs": "Czech", "hu": "Hungarian",
                "ro": "Romanian", "bg": "Bulgarian", "hr": "Croatian", "sk": "Slovak",
                "sl": "Slovenian", "et": "Estonian", "lv": "Latvian", "lt": "Lithuanian",
                "mt": "Maltese", "cy": "Welsh", "ga": "Irish", "is": "Icelandic",
                
                # Regional Spanish/European languages
                "ca": "Catalan", "eu": "Basque", "gl": "Galician",
                
                # Slavic languages
                "mk": "Macedonian", "sq": "Albanian", "sr": "Serbian", 
                "uk": "Ukrainian", "be": "Belarusian",
                
                # Central Asian languages
                "kk": "Kazakh", "ky": "Kyrgyz", "uz": "Uzbek", "tg": "Tajik", "mn": "Mongolian",
                
                # South Asian languages
                "bn": "Bengali", "te": "Telugu", "ta": "Tamil", "ml": "Malayalam",
                "kn": "Kannada", "gu": "Gujarati", "pa": "Punjabi", "ne": "Nepali",
                "si": "Sinhala",
                
                # Southeast Asian languages
                "th": "Thai", "vi": "Vietnamese", "my": "Burmese", "km": "Khmer",
                "lo": "Lao", "tr": "Turkish",
                
                # Middle Eastern languages
                "fa": "Persian", "he": "Hebrew", "ka": "Georgian", "am": "Amharic",
                
                "auto": "auto-detected language"
            }
            
            target_lang_name = language_names.get(target_language, target_language.capitalize())
            
            # Try to detect source language from text features (simple heuristic)
            # This will be enhanced in future with proper language detection
            def detect_source_language(text):
                # Simple character set based detection for common languages
                # This is a basic heuristic and should be replaced with proper language detection
                text = text.lower()
                
                # Check for specific character sets
                if re.search(r'[–∞-—è–ê-–Ø]', text):  # Cyrillic
                    return "ru"  # Russian as default for Cyrillic
                elif re.search(r'[‰∏Ä-ÈæØ]', text) or re.search(r'[\u4e00-\u9fff]', text):  # Chinese characters
                    return "zh"
                elif re.search(r'[„ÅÅ-„Çì„Ç°-„É≥]', text):  # Japanese kana
                    return "ja"
                elif re.search(r'[Í∞Ä-Ìû£]', text):  # Korean
                    return "ko"
                elif re.search(r'[◊ê-◊™]', text):  # Hebrew
                    return "he"
                elif re.search(r'[ÿß-Ÿä]', text):  # Arabic
                    return "ar"
                elif re.search(r'[‡∏Å-‡πô]', text):  # Thai
                    return "th"
                # European languages
                elif re.search(r'[√°√†√¢√§√£√•ƒÅƒÉƒÖ√®√©√™√´ƒìƒóƒô√Æ√Ø√≠ƒ´ƒØ√¨√¥√∂√≤√≥≈ì√∏≈ç√µ√π√∫√ª√º≈´ƒü√ßƒáƒç√±≈Ñ≈à≈ü≈°√ü≈æ≈∫≈º]', text):
                    # Check for specific European language markers
                    if re.search(r'[√±]', text) and re.search(r'[√°√©√≠√≥√∫]', text):
                        return "es"  # Spanish
                    elif re.search(r'[√†√¢√ß√©√®√™√´√Æ√Ø√¥√π√ª√º√ø]', text):
                        return "fr"  # French
                    elif re.search(r'[√§√∂√º√ü]', text):
                        return "de"  # German
                    elif re.search(r'[√†√®√©√¨√≠√Æ√≤√≥√π]', text):
                        return "it"  # Italian
                    elif re.search(r'[√£√µ√°√©√≠√≥√∫√ß√†]', text):
                        return "pt"  # Portuguese
                    else:
                        return "en"  # Default to English for Latin script
                else:
                    return "en"  # Default to English
            
            # Get source language
            source_lang = detect_source_language(text)
            source_lang_name = language_names.get(source_lang, "unknown language")
            
            # Build context-aware prompts
            def build_context_prompt(source_lang, target_lang, text, previous_text=None):
                """Build explicit prompts for all languages to avoid AI explanations"""
                
                # ‚úÖ CONTEXTO MEJORADO - Incluir mensaje anterior pero traducir solo el segundo
                context_section = ""
                if previous_text and previous_text.strip():
                    context_section = f"""Contexto (mensaje anterior): "{previous_text.strip()}"

IMPORTANTE: El contexto anterior es SOLO para ayudarte a entender mejor el tema. √öNICAMENTE traduce el texto que aparece despu√©s de "Texto a traducir:".

"""
                
                # ‚úÖ PROMPTS ESPEC√çFICOS PARA EVITAR EXPLICACIONES DE IA
                # Definir instrucciones estrictas por idioma de destino
                strict_instructions = {
                    "es": "SOLO traduce el texto marcado. NO agregues explicaciones, NOTAS, comentarios, aclaraciones, o cualquier texto adicional. NUNCA pongas NOTAS. √öNICAMENTE la traducci√≥n.",
                    "en": "ONLY translate the marked text. DO NOT add explanations, NOTES, comments, clarifications, or any additional text. NEVER add NOTES. ONLY the translation.",
                    "fr": "SEULEMENT traduisez le texte marqu√©. N'ajoutez PAS d'explications, de NOTES, de commentaires, de clarifications ou de texte suppl√©mentaire. JAMAIS de NOTES. SEULEMENT la traduction.",
                    "de": "NUR den markierten Text √ºbersetzen. F√ºgen Sie KEINE Erkl√§rungen, NOTIZEN, Kommentare, Erl√§uterungen oder zus√§tzlichen Text hinzu. NIEMALS NOTIZEN. NUR die √úbersetzung.",
                    "it": "SOLO traduci il testo contrassegnato. NON aggiungere spiegazioni, NOTE, commenti, chiarimenti o testo aggiuntivo. MAI NOTE. SOLO la traduzione.",
                    "pt": "APENAS traduza o texto marcado. N√ÉO adicione explica√ß√µes, NOTAS, coment√°rios, esclarecimentos ou texto adicional. NUNCA NOTAS. APENAS a tradu√ß√£o.",
                    "ru": "–¢–û–õ–¨–ö–û –ø–µ—Ä–µ–≤–µ–¥–∏—Ç–µ –æ—Ç–º–µ—á–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç. –ù–ï –¥–æ–±–∞–≤–ª—è–π—Ç–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–π, –ü–†–ò–ú–ï–ß–ê–ù–ò–ô, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤, —Ä–∞–∑—ä—è—Å–Ω–µ–Ω–∏–π –∏–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞. –ù–ò–ö–û–ì–î–ê –ü–†–ò–ú–ï–ß–ê–ù–ò–ô. –¢–û–õ–¨–ö–û –ø–µ—Ä–µ–≤–æ–¥.",
                    "zh": "‰ªÖÁøªËØëÊ†áËÆ∞ÁöÑÊñáÊú¨„ÄÇ‰∏çË¶ÅÊ∑ªÂä†Ëß£Èáä„ÄÅÊ≥®Èáä„ÄÅËØÑËÆ∫„ÄÅËØ¥ÊòéÊàñ‰ªª‰ΩïÈ¢ùÂ§ñÊñáÊú¨„ÄÇÁªù‰∏çÊ∑ªÂä†Ê≥®Èáä„ÄÇ‰ªÖÁøªËØë„ÄÇ",
                    "ja": "„Éû„Éº„ÇØ„Åï„Çå„Åü„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Åø„ÇíÁøªË®≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË™¨Êòé„ÄÅÊ≥®Èáà„ÄÅ„Ç≥„É°„É≥„Éà„ÄÅËß£Ë™¨„ÄÅËøΩÂä†„ÉÜ„Ç≠„Çπ„Éà„ÅØ‰∏ÄÂàáËøΩÂä†„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇÁµ∂ÂØæ„Å´Ê≥®Èáà„ÇíËøΩÂä†„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇÁøªË®≥„ÅÆ„Åø„ÄÇ",
                    "ko": "ÌëúÏãúÎêú ÌÖçÏä§Ìä∏Îßå Î≤àÏó≠ÌïòÏÑ∏Ïöî. ÏÑ§Î™Ö, Î©îÎ™®, ÎåìÍ∏Ä, Ìï¥ÏÑ§ ÎòêÎäî Ï∂îÍ∞Ä ÌÖçÏä§Ìä∏Î•º Ï∂îÍ∞ÄÌïòÏßÄ ÎßàÏÑ∏Ïöî. Ï†àÎåÄ Î©îÎ™®Î•º Ï∂îÍ∞ÄÌïòÏßÄ ÎßàÏÑ∏Ïöî. Î≤àÏó≠Îßå.",
                    "ar": "ÿ™ÿ±ÿ¨ŸÖ ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿ≠ÿØÿØ ŸÅŸÇÿ∑. ŸÑÿß ÿ™ÿ∂ŸäŸÅ ÿ™ŸÅÿ≥Ÿäÿ±ÿßÿ™ ÿ£Ÿà ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿ£Ÿà ÿ™ÿπŸÑŸäŸÇÿßÿ™ ÿ£Ÿà ÿ™Ÿàÿ∂Ÿäÿ≠ÿßÿ™ ÿ£Ÿà ÿ£Ÿä ŸÜÿµ ÿ•ÿ∂ÿßŸÅŸä. ŸÑÿß ÿ™ÿ∂ŸäŸÅ ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿ£ÿ®ÿØÿßŸã. ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ŸÅŸÇÿ∑.",
                    "hi": "‡§ï‡•á‡§µ‡§≤ ‡§ö‡§ø‡§π‡•ç‡§®‡§ø‡§§ ‡§™‡§æ‡§† ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§ï‡•ã‡§à ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü‡•Ä‡§ï‡§∞‡§£, ‡§®‡•ã‡§ü‡•ç‡§∏, ‡§ü‡§ø‡§™‡•ç‡§™‡§£‡•Ä, ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü‡•Ä‡§ï‡§∞‡§£ ‡§Ø‡§æ ‡§Ö‡§§‡§ø‡§∞‡§ø‡§ï‡•ç‡§§ ‡§™‡§æ‡§† ‡§® ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‡•§ ‡§ï‡§≠‡•Ä ‡§≠‡•Ä ‡§®‡•ã‡§ü‡•ç‡§∏ ‡§® ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‡•§ ‡§ï‡•á‡§µ‡§≤ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶‡•§",
                    "nl": "Vertaal ALLEEN de gemarkeerde tekst. Voeg GEEN uitleg, NOTITIES, commentaar, toelichtingen of extra tekst toe. NOOIT NOTITIES. ALLEEN de vertaling.",
                    "sv": "√ñvers√§tt ENDAST den markerade texten. L√§gg INTE till f√∂rklaringar, ANTECKNINGAR, kommentarer, f√∂rtydliganden eller extra text. ALDRIG ANTECKNINGAR. ENDAST √∂vers√§ttningen.",
                    "da": "Overs√¶t KUN den markerede tekst. Tilf√∏j IKKE forklaringer, NOTER, kommentarer, pr√¶ciseringer eller ekstra tekst. ALDRIG NOTER. KUN overs√¶ttelsen.",
                    "no": "Oversett KUN den merkede teksten. Ikke legg til forklaringer, NOTATER, kommentarer, avklaringer eller ekstra tekst. ALDRI NOTATER. KUN oversettelsen.",
                    "fi": "K√§√§nn√§ VAIN merkitty teksti. √Ñl√§ lis√§√§ selityksi√§, MUISTIINPANOJA, kommentteja, selvennyksi√§ tai ylim√§√§r√§ist√§ teksti√§. EI KOSKAAN MUISTIINPANOJA. VAIN k√§√§nn√∂s.",
                    "pl": "Przet≈Çumacz TYLKO oznaczony tekst. NIE dodawaj wyja≈õnie≈Ñ, NOTATEK, komentarzy, wyja≈õnie≈Ñ ani dodatkowego tekstu. NIGDY NOTATEK. TYLKO t≈Çumaczenie.",
                    "cs": "P≈ôelo≈æte POUZE oznaƒçen√Ω text. NEP≈òID√ÅVEJTE vysvƒõtlen√≠, POZN√ÅMKY, koment√°≈ôe, objasnƒõn√≠ nebo dal≈°√≠ text. NIKDY POZN√ÅMKY. POUZE p≈ôeklad.",
                    "hu": "CSAK a megjel√∂lt sz√∂veget ford√≠tsd le. NE adj hozz√° magyar√°zatokat, JEGYZETEKET, megjegyz√©seket, magyar√°zatokat vagy tov√°bbi sz√∂veget. SOHA JEGYZETEKET. CSAK a ford√≠t√°s.",
                    "ro": "Traduce»õi DOAR textul marcat. NU adƒÉuga»õi explica»õii, NOTE, comentarii, clarificƒÉri sau text suplimentar. NICIODATƒÇ NOTE. DOAR traducerea.",
                    "tr": "SADECE i≈üaretli metni √ßevirin. A√ßƒ±klama, NOTLAR, yorumlar, a√ßƒ±klamalar veya ek metin eklemeyin. ASLA NOT EKLEMEYƒ∞N. SADECE √ßeviri."
                }
                
                # Obtener instrucci√≥n estricta
                instruction = strict_instructions.get(target_lang, "ONLY translate the marked text. DO NOT add explanations, notes, comments, clarifications, or any additional text. ONLY the translation.")
                
                # ‚úÖ PROMPTS ESPEC√çFICOS POR PAR DE IDIOMAS CON CONTEXTO MEJORADO
                # Ingl√©s -> Espa√±ol
                if source_lang == "en" and target_lang == "es":
                    return f"""{context_section}Instrucciones: {instruction}

Texto a traducir (ingl√©s): "{text}"

Traducci√≥n al espa√±ol:"""
                
                # Espa√±ol -> Ingl√©s
                elif source_lang == "es" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (Spanish): "{text}"

English translation:"""
                
                # Ingl√©s -> Franc√©s
                elif source_lang == "en" and target_lang == "fr":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

French translation:"""
                
                # Franc√©s -> Ingl√©s
                elif source_lang == "fr" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Texte √† traduire (fran√ßais): "{text}"

English translation:"""
                
                # Ingl√©s -> Alem√°n
                elif source_lang == "en" and target_lang == "de":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

German translation:"""
                
                # Alem√°n -> Ingl√©s
                elif source_lang == "de" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Zu √ºbersetzender Text (Deutsch): "{text}"

English translation:"""
                
                # Ingl√©s -> Italiano
                elif source_lang == "en" and target_lang == "it":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Italian translation:"""
                
                # Italiano -> Ingl√©s
                elif source_lang == "it" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Testo da tradurre (italiano): "{text}"

English translation:"""
                
                # Ingl√©s -> Portugu√©s
                elif source_lang == "en" and target_lang == "pt":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Portuguese translation:"""
                
                # Portugu√©s -> Ingl√©s
                elif source_lang == "pt" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Texto para traduzir (portugu√™s): "{text}"

English translation:"""
                
                # Ingl√©s -> Ruso
                elif source_lang == "en" and target_lang == "ru":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Russian translation:"""
                
                # Ruso -> Ingl√©s
                elif source_lang == "ru" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

–¢–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ (—Ä—É—Å—Å–∫–∏–π): "{text}"

English translation:"""
                
                # Ingl√©s -> Chino
                elif source_lang == "en" and target_lang == "zh":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Chinese translation:"""
                
                # Chino -> Ingl√©s
                elif source_lang == "zh" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Ë¶ÅÁøªËØëÁöÑÊñáÊú¨ (‰∏≠Êñá): "{text}"

English translation:"""
                
                # Ingl√©s -> Japon√©s
                elif source_lang == "en" and target_lang == "ja":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Japanese translation:"""
                
                # Japon√©s -> Ingl√©s
                elif source_lang == "ja" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

ÁøªË®≥„Åô„Çã„ÉÜ„Ç≠„Çπ„Éà (Êó•Êú¨Ë™û): "{text}"

English translation:"""
                
                # Ingl√©s -> Coreano
                elif source_lang == "en" and target_lang == "ko":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Korean translation:"""
                
                # Coreano -> Ingl√©s
                elif source_lang == "ko" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Î≤àÏó≠Ìï† ÌÖçÏä§Ìä∏ (ÌïúÍµ≠Ïñ¥): "{text}"

English translation:"""
                
                # Ingl√©s -> √Årabe
                elif source_lang == "en" and target_lang == "ar":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Arabic translation:"""
                
                # √Årabe -> Ingl√©s
                elif source_lang == "ar" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿ±ÿßÿØ ÿ™ÿ±ÿ¨ŸÖÿ™Ÿá (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©): "{text}"

English translation:"""
                
                # Ingl√©s -> Hindi
                elif source_lang == "en" and target_lang == "hi":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Hindi translation:"""
                
                # Hindi -> Ingl√©s
                elif source_lang == "hi" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡§æ‡§† (‡§π‡§ø‡§Ç‡§¶‡•Ä): "{text}"

English translation:"""
                
                # Ingl√©s -> Holand√©s
                elif source_lang == "en" and target_lang == "nl":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Dutch translation:"""
                
                # Holand√©s -> Ingl√©s
                elif source_lang == "nl" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Te vertalen tekst (Nederlands): "{text}"

English translation:"""
                
                # Ingl√©s -> Sueco
                elif source_lang == "en" and target_lang == "sv":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Swedish translation:"""
                
                # Sueco -> Ingl√©s
                elif source_lang == "sv" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

Text att √∂vers√§tta (svenska): "{text}"

English translation:"""
                
                # Ingl√©s -> Turco
                elif source_lang == "en" and target_lang == "tr":
                    return f"""{context_section}Instructions: {instruction}

Text to translate (English): "{text}"

Turkish translation:"""
                
                # Turco -> Ingl√©s
                elif source_lang == "tr" and target_lang == "en":
                    return f"""{context_section}Instructions: {instruction}

√áevrilecek metin (T√ºrk√ße): "{text}"

English translation:"""
                
                # Espa√±ol -> otros idiomas
                elif source_lang == "es" and target_lang != "en":
                    return f"""{context_section}Instructions: {instruction}

Texto a traducir (espa√±ol): "{text}"

Traducci√≥n al {target_lang_name}:"""
                
                # Otros idiomas -> Espa√±ol
                elif target_lang == "es" and source_lang != "en":
                    return f"""{context_section}Instrucciones: {instruction}

Texto a traducir ({source_lang_name}): "{text}"

Traducci√≥n al espa√±ol:"""
                
                # Caso gen√©rico con instrucciones estrictas
                else:
                    return f"""{context_section}Instructions: {instruction}

Text to translate ({source_lang_name}): "{text}"

Translation to {target_lang_name}:"""
            
            # Build the prompt with context
            prompt = build_context_prompt(source_lang, target_language, text, previous_text)
            
            if config.ENABLE_DEBUG_LOGGING:
                print(f"Using context-aware prompt for {source_lang}->{target_language}")
                if previous_text:
                    print(f"Context: '{previous_text[:30]}...'")
            
            # Measure prompt preparation time
            prompt_time = time.time() - start_time
            
            # Optimized generation parameters for GPU performance
            try:
                # Start model generation timing
                generation_start_time = time.time()
                
                # Generate translation with conservative parameters
                response = generate(
                    self.translation_model,
                    self.translation_tokenizer,
                    prompt=prompt,
                    max_tokens=min(200, len(text.split()) * 8),  # ‚úÖ Aumentado de 120 a 200 y de 6x a 8x
                    verbose=False
                )
                
                generation_time = time.time() - generation_start_time
                
                if config.ENABLE_DEBUG_LOGGING:
                    print(f"Translation raw response: '{response}'")
                    print(f"üîß Generation time: {generation_time:.3f}s on {self.device}")
                
                # Start post-processing timing
                postprocess_start_time = time.time()
                
                # Enhanced cleanup for context-aware translations
                translated = response.strip()
                
                # Remove common end tokens and artifacts
                end_tokens = ["<|endoftext|>", "</s>", "<|end|>", "<|im_end|>", "[INST]", "[/INST]"]
                for token in end_tokens:
                    if token in translated:
                        translated = translated.split(token)[0].strip()
                
                # ‚úÖ DETECTAR Y REMOVER EXPLICACIONES DE IA
                explanation_patterns = [
                    # Ingl√©s
                    r"This translation conveys.*",
                    r"This conveys.*",
                    r"The translation.*",
                    r"This translates to.*",
                    r"This means.*",
                    r"In Spanish.*",
                    r"In English.*",
                    r"Note:.*",
                    r"Note that.*",
                    r"It should be noted.*",
                    r"Please note.*",
                    r"This phrase.*",
                    r"The phrase.*",
                    r"The meaning.*",
                    r"This expression.*",
                    r"In this context.*",
                    r"Here.*translation.*",
                    r"The above.*",
                    r"This captures.*",
                    r"This maintains.*",
                    r"This preserves.*",
                    r"This reflects.*",
                    
                    # Espa√±ol
                    r"Esta traducci√≥n.*",
                    r"Esta frase.*",
                    r"El significado.*",
                    r"En espa√±ol.*",
                    r"En ingl√©s.*",
                    r"Nota:.*",
                    r"Cabe se√±alar.*",
                    r"Es importante.*",
                    r"La traducci√≥n.*",
                    r"Esto significa.*",
                    r"Esta expresi√≥n.*",
                    r"En este contexto.*",
                    r"La frase.*",
                    r"Esto transmite.*",
                    r"Esto mantiene.*",
                    r"Esto preserva.*",
                    r"Esto refleja.*",
                    
                    # Franc√©s
                    r"Cette traduction.*",
                    r"Cette phrase.*",
                    r"Le sens.*",
                    r"En fran√ßais.*",
                    r"En anglais.*",
                    r"Note:.*",
                    r"Il convient.*",
                    r"La traduction.*",
                    r"Cela signifie.*",
                    r"Cette expression.*",
                    
                    # Alem√°n
                    r"Diese √úbersetzung.*",
                    r"Dieser Satz.*",
                    r"Die Bedeutung.*",
                    r"Auf Deutsch.*",
                    r"Auf Englisch.*",
                    r"Hinweis:.*",
                    r"Es ist wichtig.*",
                    r"Die √úbersetzung.*",
                    
                    # Italiano
                    r"Questa traduzione.*",
                    r"Questa frase.*",
                    r"Il significato.*",
                    r"In italiano.*",
                    r"In inglese.*",
                    r"Nota:.*",
                    r"√à importante.*",
                    r"La traduzione.*",
                    
                    # Portugu√©s
                    r"Esta tradu√ß√£o.*",
                    r"Esta frase.*",
                    r"O significado.*",
                    r"Em portugu√™s.*",
                    r"Em ingl√™s.*",
                    r"Nota:.*",
                    r"√â importante.*",
                    r"A tradu√ß√£o.*",
                    
                    # Patrones gen√©ricos
                    r"\(.*explains.*\)",
                    r"\(.*explanation.*\)",
                    r"\(.*translation.*\)",
                    r"\(.*note.*\)",
                    r"\(.*nota.*\)",
                    r"\".*translation.*\"$",
                    r"\".*explains.*\"$",
                    r"\".*conveys.*\"$",
                    r"\".*transmite.*\"$",
                    r"\".*significa.*\"$",
                    r"^(This|Esta|Cette|Diese|Questa|Esta)\s+(translation|traducci√≥n|traduction|√úbersetzung|traduzione|tradu√ß√£o).*",
                    
                    # Patrones de fin de explicaci√≥n
                    r"\..*This is.*$",
                    r"\..*Esto es.*$",
                    r"\..*C'est.*$",
                    r"\..*Das ist.*$",
                    r"\..*Questo √®.*$",
                    r"\..*Isto √©.*$"
                ]
                
                for pattern in explanation_patterns:
                    # Buscar y remover explicaciones al final
                    match = re.search(pattern, translated, re.IGNORECASE | re.DOTALL)
                    if match:
                        translated = translated[:match.start()].strip()
                        print(f"üßπ Removed AI explanation: '{match.group()[:30]}...'")
                        break
                
                # ‚úÖ DETECTAR Y LIMPIAR REPETICIONES EXCESIVAS MEJORADO
                # Detectar repeticiones de signos de puntuaci√≥n
                punct_repetition = r'([!?.,;:\-_=+])\1{10,}'
                if re.search(punct_repetition, translated):
                    translated = re.sub(punct_repetition, r'\1', translated)
                    print(f"üßπ Removed excessive punctuation repetition")
                
                # Detectar repeticiones de palabras/frases
                word_repetition = r'\b(\w+(?:\s+\w+){0,2})\s+(?:\1\s+){3,}'
                if re.search(word_repetition, translated, re.IGNORECASE):
                    # Tomar solo la primera ocurrencia antes de la repetici√≥n
                    match = re.search(word_repetition, translated, re.IGNORECASE)
                    if match:
                        translated = translated[:match.start()].strip()
                        print(f"üßπ Removed excessive word repetition pattern")
                
                # Remove training artifacts and prompts that sometimes leak through
                cleanup_prefixes = [
                    "Human:", "Assistant:", "Translation:", "Traducci√≥n:", "Traduction:", 
                    "√úbersetzung:", "Traduzione:", "Tradu√ß√£o:", "–ü–µ—Ä–µ–≤–æ–¥:", "ÁøªËØë:", 
                    "To translate", "Para traducir", "Pour traduire", "Um zu √ºbersetzen",
                    "I'll translate", "Voy a traducir", "Je vais traduire",
                    "The translation", "La traducci√≥n", "La traduction"
                ]
                
                for prefix in cleanup_prefixes:
                    if prefix in translated:
                        translated = translated.split(prefix)[0].strip()
                
                # Language-specific cleanup - remove prompt markers
                lang_markers = {
                    "Spanish:": "", "English:": "", "French:": "", "German:": "", 
                    "Italian:": "", "Portuguese:": "", "Russian:": "", "Chinese:": "",
                    "Japanese:": "", "Korean:": "", "Arabic:": "", "Hindi:": "",
                    "Espa√±ol:": "", "Ingl√©s:": "", "Franc√©s:": "", "Alem√°n:": "",
                    "Italiano:": "", "Portugu√©s:": "", "Ruso:": "", "Chino:": ""
                }
                
                for marker in lang_markers:
                    if translated.startswith(marker):
                        translated = translated[len(marker):].strip()
                        break
                    # Also check for lowercase versions
                    if translated.startswith(marker.lower()):
                        translated = translated[len(marker):].strip()
                        break
                
                # Remove quotes if the entire translation is wrapped in them
                if ((translated.startswith('"') and translated.endswith('"')) or 
                    (translated.startswith("'") and translated.endswith("'"))):
                    translated = translated[1:-1].strip()
                
                # ‚úÖ MANEJO MEJORADO DE ORACIONES M√öLTIPLES - MENOS AGRESIVO
                # Solo cortar si hay evidencia clara de que es un error (muchas oraciones muy cortas)
                sentences = re.split(r'[.!?]+\s+', translated)
                if len(sentences) > 4:  # M√°s de 4 oraciones, revisar
                    # Contar oraciones sustanciales (m√°s de 5 palabras)
                    substantial_sentences = [s for s in sentences if len(s.split()) > 5]
                    short_sentences = [s for s in sentences if len(s.split()) <= 5]
                    
                    # Si hay muchas oraciones cortas vs sustanciales, posible error
                    if len(short_sentences) > len(substantial_sentences) and len(short_sentences) > 2:
                        # Tomar solo las primeras 2-3 oraciones sustanciales
                        if substantial_sentences:
                            translated = '. '.join(substantial_sentences[:3])
                    if not translated.endswith(('.', '!', '?')):
                            translated += '.'
                            print(f"üßπ Trimmed excessive short sentences")
                
                # ‚úÖ DETECTAR Y ELIMINAR "NOTA:" O "NOTE:" AL FINAL ESPEC√çFICAMENTE
                # Eliminar patrones espec√≠ficos de notas al final de la traducci√≥n
                note_patterns_at_end = [
                    r'\s*NOTA\s*[:.].*$',  # NOTA: o NOTA. al final
                    r'\s*NOTE\s*[:.].*$',  # NOTE: o NOTE. al final
                    r'\s*Nota\s*[:.].*$',  # Nota: o Nota. al final
                    r'\s*Note\s*[:.].*$',  # Note: o Note. al final
                    r'\s*NOTES\s*[:.].*$', # NOTES: o NOTES. al final
                    r'\s*Notes\s*[:.].*$', # Notes: o Notes. al final
                    r'\s*NOTAS\s*[:.].*$', # NOTAS: o NOTAS. al final
                    r'\s*Notas\s*[:.].*$', # Notas: o Notas. al final
                    r'\s*\(NOTA\).*$',     # (NOTA) al final
                    r'\s*\(NOTE\).*$',     # (NOTE) al final
                    r'\s*\(Nota\).*$',     # (Nota) al final
                    r'\s*\(Note\).*$',     # (Note) al final
                ]
                
                for pattern in note_patterns_at_end:
                    before_cleanup = translated
                    translated = re.sub(pattern, '', translated, flags=re.IGNORECASE).strip()
                    if before_cleanup != translated:
                        print(f"üßπ Removed NOTE pattern at end: '{before_cleanup[len(translated):].strip()}'")
                        break  # Solo eliminar el primer patr√≥n encontrado
                
                # Final cleanup
                translated = translated.strip(' "\'`.,:-*()[]{}')
                
                # ‚úÖ AGREGAR PUNTO FINAL SI ES NECESARIO
                if len(translated) > 10 and not translated.endswith(('.', '!', '?', ':')):
                    translated += '.'
                
                postprocess_time = time.time() - postprocess_start_time
                
                # Enhanced validation
                if not translated or len(translated) < 2:
                    total_time = time.time() - start_time
                    print(f"‚ö†Ô∏è  Translation too short: '{translated}' (Total: {total_time:.2f}s)")
                    if config.ENABLE_DEBUG_LOGGING:
                        print(f"Translation too short: '{translated}'")
                    return f"[{target_language.upper()}] {text}"
                
                # ‚úÖ VALIDACI√ìN MEJORADA PARA DETECTAR TRADUCCIONES SIN SENTIDO
                if self._is_nonsensical_translation(translated, text):
                    total_time = time.time() - start_time
                    print(f"‚ö†Ô∏è  Nonsensical translation detected: '{translated}' (Total: {total_time:.2f}s)")
                    return f"[{target_language.upper()}] {text}"
                
                # Don't return if it's exactly the same as input (unless it's a proper noun or very short)
                if (translated.lower().strip() == text.lower().strip() and 
                    len(text.split()) > 1 and 
                    not text[0].isupper()):  # Allow proper nouns to remain the same
                    total_time = time.time() - start_time
                    print(f"‚ö†Ô∏è  Translation same as original: '{translated}' (Total: {total_time:.2f}s)")
                    if config.ENABLE_DEBUG_LOGGING:
                        print(f"Translation same as original: '{translated}'")
                    return f"[{target_language.upper()}] {text}"
                
                # Calculate final timing and statistics
                total_time = time.time() - start_time
                self.translation_times.append(total_time)
                self.total_translations += 1
                self.total_characters_translated += len(text)
                
                # Calculate statistics
                avg_time = sum(self.translation_times) / len(self.translation_times)
                chars_per_second = len(text) / total_time if total_time > 0 else 0
                
                # Enhanced timing logs with GPU info and context info
                context_marker = " (+context)" if previous_text else ""
                print(f"‚úÖ Translation complete{context_marker}: '{translated[:50]}{'...' if len(translated) > 50 else ''}'")
                print(f"‚è±Ô∏è  Timing - Prompt: {prompt_time:.3f}s | Generation: {generation_time:.3f}s | Post-proc: {postprocess_time:.3f}s | Total: {total_time:.2f}s")
                print(f"üîß Device: {self.device} | Performance: {chars_per_second:.1f} chars/sec")
                print(f"üìà Stats - Avg: {avg_time:.2f}s | Count: {self.total_translations} | Total chars: {self.total_characters_translated}")
                
                if config.ENABLE_DEBUG_LOGGING:
                    print(f"Final translation: '{text}' -> '{translated}'")
                
                return translated
                
            except Exception as gen_error:
                total_time = time.time() - start_time
                print(f"‚ùå Generation error after {total_time:.2f}s on {self.device}: {gen_error}")
                if config.ENABLE_DEBUG_LOGGING:
                    print(f"Generation error: {gen_error}")
                return f"[{target_language.upper()}] {text}"
                
        except Exception as e:
            total_time = time.time() - start_time if 'start_time' in locals() else 0
            print(f"‚ùå Translation error after {total_time:.2f}s: {e}")
            if config.ENABLE_DEBUG_LOGGING:
                print(f"Translation error: {e}")
            return f"[{target_language.upper()}] {text}"
        
        finally:
            # Optimize GPU memory after each translation if enabled
            if hasattr(config, 'MLX_CACHE_OPTIMIZATION') and config.MLX_CACHE_OPTIMIZATION:
                if self.total_translations % 10 == 0:  # Clear cache every 10 translations
                    self.optimize_gpu_memory()

    def translate_with_context(self, text, target_language="es", use_auto_context=False):
        """Translate text with automatic context from previous translations"""
        
        # Get previous translation for context if enabled
        previous_text = None
        if use_auto_context and self.translation_history:
            # Use the most recent translation as context
            previous_entry = self.translation_history[-1]
            previous_text = previous_entry.get('original_text', '')
            
            # ‚úÖ SER M√ÅS CONSERVADOR CON EL CONTEXTO
            # Solo usar contexto si es muy relevante y no muy largo
            if len(previous_text.split()) > 2 and len(previous_text.split()) < 15:
                # Verificar que el contexto anterior sea del mismo idioma aproximadamente
                current_words = set(text.lower().split()[:5])  # Primeras 5 palabras
                previous_words = set(previous_text.lower().split()[:5])  # Primeras 5 palabras
                
                # Solo usar contexto si hay alguna palabra en com√∫n (mismo tema)
                if current_words & previous_words:  # Intersecci√≥n no vac√≠a
                    if config.ENABLE_DEBUG_LOGGING:
                        print(f"üìù Using automatic context: '{previous_text[:30]}...'")
                else:
                    previous_text = None  # No usar contexto si no hay relaci√≥n
            else:
                previous_text = None  # No usar contexto si es muy corto o muy largo
        
        # Perform the translation
        translated = self.translate_text(text, target_language, previous_text)
        
        # Store in history
        history_entry = {
            'original_text': text,
            'translated_text': translated,
            'target_language': target_language,
            'timestamp': time.time(),
            'used_context': previous_text is not None
        }
        self.translation_history.append(history_entry)
        
        return translated
    
    def get_translation_history(self, limit=5):
        """Get recent translation history"""
        recent_history = list(self.translation_history)[-limit:]
        return recent_history
    
    def clear_translation_history(self):
        """Clear translation history"""
        self.translation_history.clear()
        print("üóëÔ∏è  Translation history cleared")

    def get_gpu_performance_info(self):
        """Get current GPU performance and memory information"""
        try:
            device_info = {
                "device": str(self.device),
                "peak_memory_mb": 0,
                "cache_memory_mb": 0,
                "is_gpu": str(self.device).startswith("Device(gpu")
            }
            
            try:
                device_info["peak_memory_mb"] = mx.get_peak_memory() / 1024 / 1024
            except:
                pass
                
            try:
                # Use the non-deprecated function
                device_info["cache_memory_mb"] = mx.get_cache_memory() / 1024 / 1024
            except:
                try:
                    # Fallback to deprecated function if new one doesn't exist
                    device_info["cache_memory_mb"] = mx.metal.get_cache_memory() / 1024 / 1024
                except:
                    pass
                
            return device_info
        except Exception as e:
            if config.ENABLE_DEBUG_LOGGING:
                print(f"Error getting GPU info: {e}")
            return {"device": str(self.device), "peak_memory_mb": 0, "cache_memory_mb": 0, "is_gpu": True}
    
    def optimize_gpu_memory(self):
        """Optimize GPU memory usage by clearing caches"""
        try:
            mx.clear_cache()
            if config.ENABLE_DEBUG_LOGGING:
                print("üîß MLX cache cleared for memory optimization")
        except Exception as e:
            if config.ENABLE_DEBUG_LOGGING:
                print(f"Error clearing MLX cache: {e}") 

    def _is_nonsensical_translation(self, translation, original):
        # ‚úÖ VALIDACI√ìN MEJORADA PARA DETECTAR TRADUCCIONES SIN SENTIDO
        
        # Detectar mezclas de idiomas obvias
        mixed_language_patterns = [
            r"c'√®\s+la\s+",  # Italiano mezclado con otro idioma
            r"\w+\s+la\s+armi",  # Patrones espec√≠ficos sin sentido
            r"[–∞-—è]+\s+[a-z]+\s+[–∞-—è]+",  # Cir√≠lico mezclado
            r"[‰∏Ä-ÈæØ]\s+[a-z]+\s+[‰∏Ä-ÈæØ]",  # Chino mezclado
        ]
        
        for pattern in mixed_language_patterns:
            if re.search(pattern, translation.lower()):
                return True
        
        # ‚úÖ VALIDACI√ìN MEJORADA DE LONGITUD - ser menos estricto
        original_words = len(original.split())
        translated_words = len(translation.split())
        
        # Solo marcar como sin sentido si es MUY corta (menos del 15%) Y el original es largo
        if (translated_words < original_words * 0.15 and 
            original_words > 8 and 
            translated_words < 3):  # Muy restrictivo
            return True
        
        # Detectar si solo hay puntuaci√≥n o s√≠mbolos
        clean_translation = re.sub(r'[^\w\s]', '', translation).strip()
        if len(clean_translation) < 2:
            return True
        
        return False 